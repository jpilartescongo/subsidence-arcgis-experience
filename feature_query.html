<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1, maximum-scale=1,user-scalable=no" />
    <title>Feature Query</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.14/esri/themes/light/main.css" />
    <link rel="stylesheet" href="https://js.arcgis.com/4.14/dijit/themes/claro/claro.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.4.0/Chart.min.js"></script>
    <script src="https://js.arcgis.com/4.14/"></script>
    <style>
        html,
        body,
        #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        #chartPanel {
            background: #fff;
            font: "Avenir Next W00";
            line-height: 1.5em;
            overflow: auto;
            padding: 10px;
            width: 580px;
            height: 300px;
        }

        .chart {
            height: 280px;
        }
    </style>

    <script>
        require(["esri/widgets/Sketch/SketchViewModel", "esri/geometry/Polyline", "esri/geometry/Point", "esri/Graphic", "esri/Map", "esri/views/MapView", "esri/layers/FeatureLayer", "esri/layers/GraphicsLayer",
            "esri/geometry/geometryEngine", "esri/widgets/Expand", "esri/widgets/Legend", "esri/widgets/Search", "esri/core/watchUtils"],

            function (SketchViewModel, Polyline, Point, Graphic, Map, MapView, FeatureLayer, GraphicsLayer, geometryEngine, Expand, Legend, Search, watchUtils) {

                // App 'globals'
                let sketchViewModel, featureLayerView, pausableWatchHandle, chartExpand, centerGraphic, edgeGraphic, polylineGraphic, bufferGraphic, centerGeometryAtStart, labelGraphic;

                // Units
                const unit = "miles";

                // CREATE LAYERS
                const graphicsLayer = new GraphicsLayer();
                const graphicsLayer2 = new GraphicsLayer();

                // CORS Stations
                const featureLayer = new FeatureLayer({
                    url: "https://services1.arcgis.com/BSnEnFfEn54YLVeq/arcgis/rest/services/ALL_LAYERS/FeatureServer",
                    outFields: ["*"]
                });

                // Create map
                const map = new Map({
                    basemap: "oceans",                    
                    layers: [featureLayer, graphicsLayer2, graphicsLayer]
                });

                // Create view
                const view = new MapView({
                    container: "viewDiv",
                    map: map,
                    zoom: 6,
                    center: [-91, 30]
                });


                // Set up statistics definition for client-side query
                // Total popultion of age groups by gender in census tracts

                //const statDefinitions = ["HoustonNet", "COCONet", "GulfNet", "TLALOCNet", "Operational", "Decommissioned", "Non-Operational"].map(function (fieldName) {
                const statDefinitions = ["SAMPLING"].map(function (fieldName) {
                    return {
                        onStatisticField: fieldName,
                        outStatisticFieldName: fieldName + "_TOTAL",
                        statisticType: "count"
                    };
                });

                // Update User Interface
                setUpAppUI();
                setUpSketch();

                function setUpAppUI() {
                    // When layer is loaded, create a watcher to trigger drawing of the buffer polygon
                    view.whenLayerView(featureLayer).then(function (layerView) {
                        featureLayerView = layerView;
                        pausableWatchHandle = watchUtils.pausable(
                            layerView,
                            "updating",
                            function (val) {
                                if (!val) {
                                    drawBufferPolygon();
                                }
                            }
                        );

                        // Display directions when the layerView is loading
                        watchUtils.whenFalseOnce(layerView, "updating", function () {
                            view.popup.open({
                                title: "Center point",
                                content:
                                    "Drag this point to move the buffer.<br/> " + "Or drag the <b>Edge</b> point to resize the buffer.",
                                location: centerGraphic.geometry
                            });
                            view.popup.alignment = "top-left";
                        });
                    });

                    view.when(function () {
                        // Display the chart in an Expand widget
                        chartExpand = new Expand({
                            expandIconClass: "esri-icon-chart",
                            expandTooltip: "Population pyramid chart",
                            expanded: false,
                            view: view,
                            content: document.getElementById("chartPanel")
                        });

                        const search = new Search({
                            view: view,
                            resultGraphicEnabled: false,
                            popupEnabled: false
                        });

                        // Resume drawBufferPolygon() function; user searched for a new location. Must update the buffer polygon and re-run the stats query
                        search.on("search-complete", function () {
                            pausableWatchHandle.resume();
                        });


                        // Legend widget
                        const legend = new Legend({
                            view: view,
                            layerInfos: [
                                {
                                    layer: featureLayer,
                                    title: "NOAA/NSRS CORS Stations"
                                }                                
                            ]
                        });

                        // Display the Legend in an Expand widget
                        const legendExpand = new Expand({
                            expandTooltip: "Show Legend",
                            expanded: false,
                            view: view,
                            content: legend
                        });

                        // Add our components to the UI
                        view.ui.add(chartExpand, "bottom-left");
                        view.ui.add(search, "top-right");
                        view.ui.add(legendExpand, "bottom-right");
                    });

                    // Close the 'help' popup when view is focused
                    view.watch("focused", function (newValue) {
                        if (newValue) {
                            view.popup.close();
                        }
                    });
                }

                // CREATE SKETCHVIEWMODEL AND WIRE UP EVENT LISTENERS
                function setUpSketch() {
                    sketchViewModel = new SketchViewModel({
                        view: view,
                        layer: graphicsLayer
                    });

                    // Listen to SketchViewModel's update event so that population pyramid chart is updated as the graphics are updated
                    sketchViewModel.on("update", onMove);
                }


                /*********************************************************************
                 * Edge or center graphics are being moved. Recalculate the buffer with
                 * updated geometry information and run the query stats again.
                 *********************************************************************/
                function onMove(event) {
                    // If the edge graphic is moving, keep the center graphic
                    // at its initial location. Only move edge graphic
                    if (
                        event.toolEventInfo &&
                        event.toolEventInfo.mover.attributes.edge
                    ) {
                        const toolType = event.toolEventInfo.type;
                        if (toolType === "move-start") {
                            centerGeometryAtStart = centerGraphic.geometry;
                        }
                        // keep the center graphic at its initial location when edge point is moving
                        else if (toolType === "move" || toolType === "move-stop") {
                            centerGraphic.geometry = centerGeometryAtStart;
                        }
                    }

                    // the center or edge graphic is being moved, recalculate the buffer
                    const vertices = [
                        [centerGraphic.geometry.x, centerGraphic.geometry.y],
                        [edgeGraphic.geometry.x, edgeGraphic.geometry.y]
                    ];

                    // client-side stats query of features that intersect the buffer
                    calculateBuffer(vertices);

                    // user is clicking on the view... call update method with the center and edge graphics
                    if (event.state === "cancel" || event.state === "complete") {
                        sketchViewModel.update([edgeGraphic, centerGraphic], {
                            tool: "move"
                        });
                    }
                }

                /*********************************************************************
                 * Edge or center point is being updated. Recalculate the buffer with
                 * updated geometry information.
                 *********************************************************************/
                function calculateBuffer(vertices) {
                    // Update the geometry of the polyline based on location of edge and center points
                    polylineGraphic.geometry = new Polyline({
                        paths: vertices,
                        spatialReference: view.spatialReference
                    });

                    // Recalculate the polyline length and buffer polygon
                    const length = geometryEngine.geodesicLength(
                        polylineGraphic.geometry,
                        unit
                    );
                    const buffer = geometryEngine.geodesicBuffer(
                        centerGraphic.geometry,
                        length,
                        unit
                    );

                    // Update the buffer polygon
                    bufferGraphic.geometry = buffer;

                    // Query female and male age groups of the census tracts that intersect
                    // the buffer polygon on the client
                    queryLayerViewStationStats(buffer).then(function (newData) {
                        // Create a population pyramid chart from the returned result
                        updateChart(newData);
                    });

                    // Update label graphic to show the length of the polyline
                    labelGraphic.geometry = edgeGraphic.geometry;
                    labelGraphic.symbol = {
                        type: "text",
                        color: "#000000",
                        text: length.toFixed(2) + " miles",
                        xoffset: 50,
                        yoffset: 10,
                        font: {
                            // autocast as Font
                            size: 14,
                            family: "sans-serif"
                        }
                    };
                }

                /*********************************************************************
                 * Spatial query the census tracts feature layer view for statistics
                 * using the updated buffer polygon.
                *********************************************************************/
                function queryLayerViewStationStats(buffer) {
                    // Data storage for the chart                    
                    let CBI_cGPs_Data = [], COCONet_Data = [], CORS_Stations_Data = [], GulfNet_Data = [], HoustonNet_Data = [], Tide_Gauges_Data = [], TLALOCNet_Data = [], TxDOT_RRPs_Data = [];

                    // Client-side spatial query:
                    // Get a sum of age groups for census tracts that intersect the polygon buffer
                    const query = featureLayerView.layer.createQuery();
                    query.outStatistics = statDefinitions;
                    query.geometry = buffer;


                    // Query the features on the client using FeatureLayerView.queryFeatures
                    return featureLayerView
                        .queryFeatures(query)
                        .then(function (results) {
                            // Statistics query returns a feature with 'stats' as attributes
                            const attributes = results.features[0].attributes;
                            // Loop through attributes and save the values for use in each of the stations or tide gauges
                            for (var key in attributes) {                                
                                if (key.includes("CBI_cGPS_Count")) {
                                    CBI_cGPs_Data.push(attributes[key]);
                                }
                                if (key.includes("COCONet_Count")) {
                                    COCONet_Data.push(attributes[key]);
                                } 
                                if (key.includes("CORS_Stations_Count")) {
                                    CORS_Stations_Data.push(attributes[key]);
                                }
                                if (key.includes("GulfNet_Count")) {
                                    GulfNet_Data.push(attributes[key]);
                                } 
                                if (key.includes("HoustonNet_Count")) {
                                    HoustonNet_Data.push(attributes[key]);
                                } 
                                if (key.includes("Tide_Gauges_Count")) {
                                    Tide_Gauges_Data.push(attributes[key]);
                                } 
                                if (key.includes("TLALOCNet_Count")) {
                                    TLALOCNet_Data.push(attributes[key]);
                                } 
                                if (key.includes("TxDOT_RRPs_Count")) {
                                    TxDOT_RRPs_Data.push(attributes[key]);
                                } 
                                else {
                                    // print nothing
                                    console.log('invalid input');
                                }
                            }
                            // Return information, seperated by gender                            
                            return [CBI_cGPs_Data, COCONet_Data, CORS_Stations_Data, GulfNet_Data, HoustonNet_Data, Tide_Gauges_Data, TLALOCNet_Data, TxDOT_RRPs_Data];
                        })
                        .catch(function (error) {
                            console.log(error);
                        });
                }
                

                /*******************************************************************************************
                 * Draw the buffer polygon when application loads or when user searches for a new location
                 ******************************************************************************************/
                function drawBufferPolygon() {
                    // When pause() is called on the watch handle, the callback represented by the
                    // watch is no longer invoked, but is still available for later use
                    // this watch handle will be resumed when user searches for a new location
                    pausableWatchHandle.pause();

                    // Initial location for the center, edge and polylines on the view
                    const viewCenter = view.center.clone();
                    const centerScreenPoint = view.toScreen(viewCenter);
                    const centerPoint = view.toMap({
                        x: centerScreenPoint.x - 100,
                        y: centerScreenPoint.y - 50
                    });
                    const edgePoint = view.toMap({
                        x: centerScreenPoint.x,
                        y: centerScreenPoint.y
                    });

                    // Store updated vertices
                    const vertices = [
                        [centerPoint.x, centerPoint.y],
                        [edgePoint.x, edgePoint.y]
                    ];

                    // Create center, edge, polyline and buffer graphics for the first time
                    if (!centerGraphic) {
                        const polyline = new Polyline({
                            paths: vertices,
                            spatialReference: view.spatialReference
                        });

                        // get the length of the initial polyline and create buffer
                        const length = geometryEngine.geodesicLength(polyline, unit);
                        const buffer = geometryEngine.geodesicBuffer(
                            centerPoint,
                            length,
                            unit
                        );

                        // Create the graphics representing the line and buffer
                        const pointSymbol = {
                            type: "simple-marker",
                            style: "circle",
                            size: 10,
                            color: [0, 0, 0, 0.5]
                        };
                        centerGraphic = new Graphic({
                            geometry: centerPoint,
                            symbol: pointSymbol,
                            attributes: {
                                center: "center"
                            }
                        });

                        edgeGraphic = new Graphic({
                            geometry: edgePoint,
                            symbol: pointSymbol,
                            attributes: {
                                edge: "edge"
                            }
                        });

                        polylineGraphic = new Graphic({
                            geometry: polyline,
                            symbol: {
                                type: "simple-line",
                                color: [0, 0, 150, 1], // diameter line
                                width: 2.5
                            }
                        });

                        // color properties for buffer circle
                        bufferGraphic = new Graphic({
                            geometry: buffer,
                            symbol: {
                                type: "simple-fill",
                                color: [0, 0, 150, 0.3], // interior
                                outline: {
                                    color: [0, 0, 150], // exterior
                                    width: 2
                                }
                            }
                        });
                        labelGraphic = labelLength(edgePoint, length);

                        // Add graphics to layer
                        graphicsLayer.addMany([centerGraphic, edgeGraphic]);
                        // once center and edge point graphics are added to the layer,
                        // call sketch's update method pass in the graphics so that users
                        // can just drag these graphics to adjust the buffer
                        setTimeout(function () {
                            sketchViewModel.update([edgeGraphic, centerGraphic], {
                                tool: "move"
                            });
                        }, 1000);

                        graphicsLayer2.addMany([
                            bufferGraphic,
                            polylineGraphic,
                            labelGraphic
                        ]);
                    }
                    // Move the center and edge graphics to the new location returned from search
                    else {
                        centerGraphic.geometry = centerPoint;
                        edgeGraphic.geometry = edgePoint;
                    }

                    // Query features that intersect the buffer
                    calculateBuffer(vertices);
                }

                let chart;

                // ORIGINAL CHART
                function updateChart(newData) {
                    chartExpand.expanded = true;

                    const CORS_Stations_Data = newData[0];
                    const CBI_cGPS_Data = newData[1];

                    if (!chart) {
                        // Get the canvas element and render the chart in it
                        const canvasElement = document.getElementById("chart");

                        chart = new Chart(canvasElement.getContext("2d"), {
                            type: "horizontalBar",
                            data: {
                                // count
                                labels: [
                                    "90+",
                                    "50-89",
                                    "40-49",
                                    "30-39",
                                    "20-29",
                                    "10-19",
                                    "0-9"
                                ],
                                datasets: [
                                    {
                                        label: "CORS Stations",
                                        backgroundColor: "#000000",
                                        borderColor: "#7F00FF",
                                        borderWidth: 0.25,
                                        data: CORS_Stations_Data
                                    },
                                    {
                                        label: "CBI cGPS",
                                        backgroundColor: "#0080FF",
                                        borderColor: "#004C99",
                                        borderWidth: 0.25,
                                        data: CBI_cGPS_Data
                                    }
                                ]
                            },
                            options: {
                                responsive: false,
                                legend: {
                                    position: "bottom"
                                },
                                title: {
                                    display: true,
                                    text: "Count of Stations"
                                },
                                scales: {
                                    yAxes: [
                                        {
                                            categorySpacing: 0,
                                            barThickness: 10,
                                            stacked: true,
                                            scaleLabel: {
                                                display: true,
                                                labelString: "Number of Stations"
                                            }
                                        }
                                    ],
                                    xAxes: [
                                        {
                                            ticks: {
                                                callback: function (value) {
                                                    const val = Math.abs(parseInt(value));
                                                    return numberWithCommas(val);
                                                }
                                            },
                                            scaleLabel: {
                                                display: true,
                                                labelString: "Category"
                                            }
                                        }
                                    ]
                                },
                                tooltips: {
                                    callbacks: {
                                        label: function (tooltipItem, data) {
                                            return (
                                                data.datasets[tooltipItem.datasetIndex].label +
                                                ": " +
                                                numberWithCommas(Math.abs(tooltipItem.xLabel))
                                            );
                                        }
                                    }
                                }
                            }
                        });
                    }
                    else {
                        chart.data.datasets[0].data = CORS_Stations_Data;
                        chart.data.datasets[1].data = CBI_cGPS_Data;
                        chart.update();
                    }
                }

                // Helper function for formatting number labels with commas
                function numberWithCommas(value) {
                    value = value || 0;
                    return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
                }

                // Label polyline with its length
                function labelLength(geom, length) {
                    return new Graphic({
                        geometry: geom,
                        symbol: {
                            type: "text",
                            color: "#FFEB00",
                            text: length.toFixed(2) + " miles",
                            xoffset: 50,
                            yoffset: 10,
                            font: {
                                // autocast as Font
                                size: 14,
                                family: "sans-serif"
                            }
                        }
                    });
                }
            });
    </script>
</head>

<body>
    <div id="viewDiv"></div>
    <div id="chartPanel"><canvas id="chart" class="chart"></canvas></div>
</body>
</html>
